package service

import (
	"context"
	"time"

	"captcha-service/internal/domain/entity"
	"captcha-service/internal/domain/interfaces"
	"captcha-service/pkg/logger"

	"go.uber.org/zap"
)

type CaptchaService struct {
	repo          interfaces.ChallengeRepository
	registry      *GeneratorRegistry
	wsSender      interfaces.WebSocketSender
	config        *entity.Config
	userAttempts  *entity.UserAttempts
	globalBlocker *GlobalUserBlocker
}

func NewCaptchaService(repo interfaces.ChallengeRepository, registry *GeneratorRegistry, wsSender interfaces.WebSocketSender, config *entity.Config) *CaptchaService {
	return &CaptchaService{
		repo:     repo,
		registry: registry,
		wsSender: wsSender,
		config:   config,
		userAttempts: entity.NewUserAttempts(&entity.DemoConfig{
			MaxAttempts:   config.MaxAttempts,
			BlockDuration: config.BlockDurationMin,
		}),
		globalBlocker: NewGlobalUserBlocker(config),
	}
}

func (s *CaptchaService) CreateChallenge(ctx context.Context, challengeType string, complexity int32, userID string) (*entity.Challenge, error) {
	// Check if user is blocked globally before creating challenge
	if s.globalBlocker.IsUserBlocked(userID) {
		logger.Warn("User is globally blocked, cannot create challenge", zap.String("userID", userID))
		return nil, entity.ErrUserBlocked
	}

	generator, exists := s.registry.Get(challengeType)
	if !exists {
		return nil, entity.ErrChallengeNotFound
	}

	challenge, err := generator.Generate(ctx, complexity, userID)
	if err != nil {
		return nil, err
	}

	if err := s.repo.SaveChallenge(ctx, challenge); err != nil {
		return nil, err
	}

	// HTML generation is handled by the generator
	challenge.HTML = "<!-- HTML will be generated by the frontend -->"
	return challenge, nil
}

func (s *CaptchaService) ValidateChallenge(ctx context.Context, challengeID string, answer interface{}) (bool, int32, error) {
	challenge, err := s.repo.GetChallenge(ctx, challengeID)
	if err != nil {
		return false, 0, err
	}

	if challenge.Attempts >= challenge.MaxAttempts {
		challenge.IsBlocked = true
		challenge.BlockReason = "Max attempts exceeded"
		blockDuration := time.Duration(challenge.MaxAttempts) * time.Minute
		blockedUntil := time.Now().Add(blockDuration)
		challenge.BlockedUntil = &blockedUntil

		// Update is handled by the repository automatically

		return false, 0, entity.ErrMaxAttemptsReached
	}

	if challenge.IsBlocked && challenge.BlockedUntil != nil && time.Now().Before(*challenge.BlockedUntil) {
		return false, 0, entity.ErrChallengeBlocked
	}

	generator, exists := s.registry.Get(challenge.Type)
	if !exists {
		return false, 0, entity.ErrChallengeNotFound
	}

	valid, confidence, err := generator.Validate(answer, challenge.Data)
	if err != nil {
		return false, 0, err
	}

	challenge.Attempts++
	// Update is handled by the repository automatically

	// Record attempt in global user blocker
	if !valid {
		isBlocked, remainingAttempts := s.globalBlocker.RecordAttempt(challenge.UserID, challengeID)
		logger.Info("Failed attempt recorded globally",
			zap.String("userID", challenge.UserID),
			zap.String("challengeID", challengeID),
			zap.Int32("remainingAttempts", remainingAttempts),
			zap.Bool("isBlocked", isBlocked))

		if isBlocked {
			logger.Warn("User blocked globally due to max attempts", zap.String("userID", challenge.UserID))
		}
	} else {
		// Reset attempts on successful validation
		s.globalBlocker.ResetAttempts(challenge.UserID)
		logger.Info("User attempts reset globally after successful validation", zap.String("userID", challenge.UserID))
	}

	return valid, confidence, nil
}

func (s *CaptchaService) GetChallenge(ctx context.Context, challengeID string) (*entity.Challenge, error) {
	return s.repo.GetChallenge(ctx, challengeID)
}

func (s *CaptchaService) ProcessEvent(ctx context.Context, event *entity.WebSocketMessage) error {
	logger.Debug("Processing WebSocket event",
		zap.String("type", event.Type),
		zap.String("user_id", event.UserID))

	switch event.Type {
	case entity.MessageTypeChallengeRequest:
		return s.handleChallengeRequest(ctx, event)
	case entity.MessageTypeCaptchaEvent:
		return s.handleCaptchaEvent(ctx, event)
	default:
		logger.Warn("Unknown event type", zap.String("type", event.Type))
		return nil
	}
}

func (s *CaptchaService) handleChallengeRequest(ctx context.Context, event *entity.WebSocketMessage) error {
	challenge, err := s.CreateChallenge(ctx, "slider-puzzle", 50, event.UserID)
	if err != nil {
		return err
	}

	response := &entity.WebSocketMessage{
		Type:   entity.MessageTypeChallengeCreated,
		UserID: event.UserID,
		Data: map[string]interface{}{
			"challenge_id": challenge.ID,
			"html":         challenge.HTML,
		},
	}

	return s.wsSender.SendMessage(event.UserID, response)
}

func (s *CaptchaService) handleCaptchaEvent(ctx context.Context, event *entity.WebSocketMessage) error {
	if event.Type == entity.MessageTypeChallengeCompleted {
		return s.handleChallengeCompleted(ctx, event)
	}
	return nil
}

func (s *CaptchaService) handleChallengeCompleted(ctx context.Context, event *entity.WebSocketMessage) error {
	challengeID, ok := event.Data["challenge_id"].(string)
	if !ok {
		return entity.ErrChallengeNotFound
	}
	challenge, err := s.repo.GetChallenge(ctx, challengeID)
	if err != nil {
		return err
	}

	generator, exists := s.registry.Get(challenge.Type)
	if !exists {
		return entity.ErrChallengeNotFound
	}

	valid, _, err := generator.Validate(event.Data, challenge.Data)
	if err != nil {
		return err
	}

	if !valid {
		challenge, err := s.CreateChallenge(ctx, "slider-puzzle", 50, event.UserID)
		if err != nil {
			return err
		}

		response := &entity.WebSocketMessage{
			Type:   entity.MessageTypeNewChallenge,
			UserID: event.UserID,
			Data: map[string]interface{}{
				"challenge_id": challenge.ID,
				"html":         challenge.HTML,
			},
		}

		return s.wsSender.SendMessage(event.UserID, response)
	}

	return nil
}
