package service

import (
	"context"

	"captcha-service/internal/config"
	"captcha-service/internal/domain/entity"
	"captcha-service/pkg/logger"

	"go.uber.org/zap"
)

type ChallengeRepository interface {
	SaveChallenge(ctx context.Context, challenge *entity.Challenge) error
	GetChallenge(ctx context.Context, challengeID string) (*entity.Challenge, error)
	DeleteChallenge(ctx context.Context, challengeID string) error
}

type WebSocketSender interface {
	SendMessage(userID string, message interface{}) error
}

type CaptchaService struct {
	repo          ChallengeRepository
	registry      *GeneratorRegistry
	config        *config.CaptchaConfig
	userAttempts  *entity.UserAttempts
	globalBlocker *GlobalUserBlocker
}

func NewCaptchaService(repo ChallengeRepository, registry *GeneratorRegistry, cfg *config.CaptchaConfig) *CaptchaService {
	return &CaptchaService{
		repo:     repo,
		registry: registry,
		config:   cfg,
		userAttempts: entity.NewUserAttempts(&config.DemoConfig{
			MaxAttempts:   cfg.MaxAttempts,
			BlockDuration: cfg.BlockDurationMin,
		}),
		globalBlocker: NewGlobalUserBlocker(&config.ServiceConfig{
			MaxAttempts:      cfg.MaxAttempts,
			BlockDurationMin: cfg.BlockDurationMin,
			CleanupInterval:  cfg.CleanupInterval,
			StaleThreshold:   cfg.StaleThreshold,
		}),
	}
}

func (s *CaptchaService) CreateChallenge(ctx context.Context, challengeType string, complexity int32, userID string) (*entity.Challenge, error) {
	if s.globalBlocker.IsUserBlocked(userID) {
		logger.Warn("User is globally blocked, cannot create challenge", zap.String("userID", userID))
		return nil, entity.ErrUserBlocked
	}

	generator, exists := s.registry.Get(challengeType)
	if !exists {
		return nil, entity.ErrChallengeNotFound
	}

	challenge, err := generator.Generate(ctx, complexity, userID)
	if err != nil {
		return nil, err
	}

	if err := s.repo.SaveChallenge(ctx, challenge); err != nil {
		return nil, err
	}

	challenge.HTML = "<!-- HTML will be generated by the frontend -->"
	return challenge, nil
}

func (s *CaptchaService) ValidateChallenge(ctx context.Context, challengeID string, answer interface{}) (bool, int32, error) {
	challenge, err := s.repo.GetChallenge(ctx, challengeID)
	if err != nil {
		return false, 0, err
	}

	if s.globalBlocker.IsUserBlocked(challenge.UserID) {
		logger.Warn("User is globally blocked, cannot validate challenge", zap.String("userID", challenge.UserID))
		return false, 0, entity.ErrUserBlocked
	}

	generator, exists := s.registry.Get(challenge.Type)
	if !exists {
		return false, 0, entity.ErrChallengeNotFound
	}

	valid, confidence, err := generator.Validate(answer, challenge.Data)
	if err != nil {
		return false, 0, err
	}

	challenge.Attempts++

	if !valid {
		isBlocked, remainingAttempts := s.globalBlocker.RecordAttempt(challenge.UserID, challengeID)
		logger.Info("Failed attempt recorded globally",
			zap.String("userID", challenge.UserID),
			zap.String("challengeID", challengeID),
			zap.Int32("remainingAttempts", remainingAttempts),
			zap.Bool("isBlocked", isBlocked))

		if isBlocked {
			logger.Warn("User blocked globally due to max attempts", zap.String("userID", challenge.UserID))
		}
	} else {
		s.globalBlocker.ResetAttempts(challenge.UserID)
		logger.Info("User attempts reset globally after successful validation", zap.String("userID", challenge.UserID))
	}

	return valid, confidence, nil
}

func (s *CaptchaService) GetChallenge(ctx context.Context, challengeID string) (*entity.Challenge, error) {
	return s.repo.GetChallenge(ctx, challengeID)
}
