package service

import (
	"context"

	"captcha-service/internal/domain/entity"
	"captcha-service/pkg/logger"

	"go.uber.org/zap"
)

type ChallengeRepository interface {
	SaveChallenge(ctx context.Context, challenge *entity.Challenge) error
	GetChallenge(ctx context.Context, challengeID string) (*entity.Challenge, error)
	DeleteChallenge(ctx context.Context, challengeID string) error
}

type WebSocketSender interface {
	SendMessage(userID string, message interface{}) error
}

type CaptchaService struct {
	repo          ChallengeRepository
	registry      *GeneratorRegistry
	wsSender      WebSocketSender
	config        *entity.Config
	userAttempts  *entity.UserAttempts
	globalBlocker *GlobalUserBlocker
}

func NewCaptchaService(repo ChallengeRepository, registry *GeneratorRegistry, wsSender WebSocketSender, config *entity.Config) *CaptchaService {
	return &CaptchaService{
		repo:     repo,
		registry: registry,
		wsSender: wsSender,
		config:   config,
		userAttempts: entity.NewUserAttempts(&entity.DemoConfig{
			MaxAttempts:   config.MaxAttempts,
			BlockDuration: config.BlockDurationMin,
		}),
		globalBlocker: NewGlobalUserBlocker(config),
	}
}

func (s *CaptchaService) CreateChallenge(ctx context.Context, challengeType string, complexity int32, userID string) (*entity.Challenge, error) {
	if s.globalBlocker.IsUserBlocked(userID) {
		logger.Warn("User is globally blocked, cannot create challenge", zap.String("userID", userID))
		return nil, entity.ErrUserBlocked
	}

	generator, exists := s.registry.Get(challengeType)
	if !exists {
		return nil, entity.ErrChallengeNotFound
	}

	challenge, err := generator.Generate(ctx, complexity, userID)
	if err != nil {
		return nil, err
	}

	if err := s.repo.SaveChallenge(ctx, challenge); err != nil {
		return nil, err
	}

	challenge.HTML = "<!-- HTML will be generated by the frontend -->"
	return challenge, nil
}

func (s *CaptchaService) ValidateChallenge(ctx context.Context, challengeID string, answer interface{}) (bool, int32, error) {
	challenge, err := s.repo.GetChallenge(ctx, challengeID)
	if err != nil {
		return false, 0, err
	}

	if s.globalBlocker.IsUserBlocked(challenge.UserID) {
		logger.Warn("User is globally blocked, cannot validate challenge", zap.String("userID", challenge.UserID))
		return false, 0, entity.ErrUserBlocked
	}

	generator, exists := s.registry.Get(challenge.Type)
	if !exists {
		return false, 0, entity.ErrChallengeNotFound
	}

	valid, confidence, err := generator.Validate(answer, challenge.Data)
	if err != nil {
		return false, 0, err
	}

	challenge.Attempts++

	if !valid {
		isBlocked, remainingAttempts := s.globalBlocker.RecordAttempt(challenge.UserID, challengeID)
		logger.Info("Failed attempt recorded globally",
			zap.String("userID", challenge.UserID),
			zap.String("challengeID", challengeID),
			zap.Int32("remainingAttempts", remainingAttempts),
			zap.Bool("isBlocked", isBlocked))

		if isBlocked {
			logger.Warn("User blocked globally due to max attempts", zap.String("userID", challenge.UserID))
		}
	} else {
		s.globalBlocker.ResetAttempts(challenge.UserID)
		logger.Info("User attempts reset globally after successful validation", zap.String("userID", challenge.UserID))
	}

	return valid, confidence, nil
}

func (s *CaptchaService) GetChallenge(ctx context.Context, challengeID string) (*entity.Challenge, error) {
	return s.repo.GetChallenge(ctx, challengeID)
}

func (s *CaptchaService) ProcessEvent(ctx context.Context, event *entity.WebSocketMessage) error {
	logger.Debug("Processing WebSocket event",
		zap.String("type", event.Type),
		zap.String("user_id", event.UserID))

	switch event.Type {
	case entity.MessageTypeChallengeRequest:
		return s.handleChallengeRequest(ctx, event)
	case entity.MessageTypeCaptchaEvent:
		return s.handleCaptchaEvent(ctx, event)
	default:
		logger.Warn("Unknown event type", zap.String("type", event.Type))
		return nil
	}
}

func (s *CaptchaService) handleChallengeRequest(ctx context.Context, event *entity.WebSocketMessage) error {
	challenge, err := s.CreateChallenge(ctx, entity.ChallengeTypeSliderPuzzle, 50, event.UserID)
	if err != nil {
		return err
	}

	response := &entity.WebSocketMessage{
		Type:   entity.MessageTypeChallengeCreated,
		UserID: event.UserID,
		Data: map[string]interface{}{
			entity.FieldChallengeID: challenge.ID,
			"html":                  challenge.HTML,
		},
	}

	return s.wsSender.SendMessage(event.UserID, response)
}

func (s *CaptchaService) handleCaptchaEvent(ctx context.Context, event *entity.WebSocketMessage) error {
	if event.Type == entity.MessageTypeChallengeCompleted {
		return s.handleChallengeCompleted(ctx, event)
	}
	return nil
}

func (s *CaptchaService) handleChallengeCompleted(ctx context.Context, event *entity.WebSocketMessage) error {
	challengeID, ok := event.Data[entity.FieldChallengeID].(string)
	if !ok {
		return entity.ErrChallengeNotFound
	}
	challenge, err := s.repo.GetChallenge(ctx, challengeID)
	if err != nil {
		return err
	}

	generator, exists := s.registry.Get(challenge.Type)
	if !exists {
		return entity.ErrChallengeNotFound
	}

	valid, _, err := generator.Validate(event.Data, challenge.Data)
	if err != nil {
		return err
	}

	if !valid {
		challenge, err := s.CreateChallenge(ctx, entity.ChallengeTypeSliderPuzzle, 50, event.UserID)
		if err != nil {
			return err
		}

		response := &entity.WebSocketMessage{
			Type:   entity.MessageTypeNewChallenge,
			UserID: event.UserID,
			Data: map[string]interface{}{
				entity.FieldChallengeID: challenge.ID,
				"html":                  challenge.HTML,
			},
		}

		return s.wsSender.SendMessage(event.UserID, response)
	}

	return nil
}
