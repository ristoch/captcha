<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Капча — Слайдер-пазл</title>
  <style>
    :root { 
      --w: {{.CanvasWidth}}px; 
      --h: {{.CanvasHeight}}px; 
      --pz: {{.PuzzleWidth}}px; 
      --gap-top: 50px; 
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Arial, sans-serif; background: #f5f5f5; color:#222; }
    .wrap { max-width: 480px; margin: 24px auto; background: #fff; border-radius: 10px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,.08); }
    h1 { font-size: 18px; margin: 0 0 10px; text-align:center; }
    .canvas-box { position: relative; width: var(--w); height: var(--h); margin: 12px auto; border: 1px solid #e5e5e5; border-radius: 8px; overflow: hidden; background: #fafafa; }
    canvas { display:block; width:100%; height:100%; }
    .piece { position:absolute; top: var(--gap-top); left: 0; width: var(--pz); height: var(--pz); background:transparent; box-shadow: 0 4px 10px rgba(0,0,0,.15); display:grid; place-items:center; }
    .ctrl { width: var(--w); margin: 12px auto 0; }
    input[type="range"] { width:100%; height: 34px; -webkit-appearance:none; appearance:none; background:#e9ecef; border-radius: 999px; outline: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:34px; height:34px; border-radius:50%; background:#1976d2; border:3px solid #fff; box-shadow: 0 2px 6px rgba(0,0,0,.25); cursor:pointer; }
    input[type="range"]::-moz-range-thumb { width:34px; height:34px; border-radius:50%; background:#1976d2; border:3px solid #fff; box-shadow: 0 2px 6px rgba(0,0,0,.25); cursor:pointer; }
    .msg { text-align:center; margin:10px 0 0; font-weight:600; }
    .ok { color:#1b5e20; }
    .bad { color:#b00020; }
    .hint { text-align:center; font-size:13px; color:#666; margin-top:6px; }
    .noselect { user-select: none; -webkit-user-select:none; }
  </style>
</head>
<body>
  <div class="wrap noselect">
    <h1>Переместите слайдер для решения капчи</h1>
    <div class="canvas-box">
      <canvas id="cv" width="{{.CanvasWidth}}" height="{{.CanvasHeight}}" aria-label="captcha"></canvas>
      <div id="piece" class="piece" aria-hidden="true"></div>
    </div>
    <div class="ctrl">
      <input id="slider" type="range" min="0" max="{{.CanvasWidth}}" value="0" />
    </div>
    <div id="msg" class="msg"></div>
  </div>

  <script>
    function sendToParent(type, data) {
      if (window.top && window.top !== window) {
        window.top.postMessage({
          type: 'captcha:sendData',
          challengeId: challengeData.challenge_id,
          eventType: type,
          data: data
        }, '*');
      }
    }

    function handleParentMessage(event) {
      if (event.data?.type === 'captcha:serverData') {
        const { challengeId, eventType, data } = event.data;
        if (challengeId === challengeData.challenge_id) {
          handleServerEvent(eventType, data);
        }
      }
    }

    function handleServerEvent(eventType, data) {
      switch (eventType) {
        case 'updateChallenge':
          if (data.jsCode) {
            eval(data.jsCode);
          }
          break;
        case 'updateData':
          if (data.newData) {
            Object.assign(challengeData, data.newData);
            redrawCanvas();
          }
          break;
        case 'hint':
          showMessage(data.message, 'hint');
          break;
        case 'new_challenge':
          
          if (data.challenge_id) {
            challengeData.challenge_id = data.challenge_id;
          }
          if (data.html) {
            
            document.body.innerHTML = data.html;
            return;
          }
          
          if (data.newData) {
            Object.assign(challengeData, data.newData);
            redrawCanvas();
          }
          
          slider.value = 0;
          setMsg("Новая капча загружена. Попробуйте снова.", "hint");
          break;
      }
    }

    window.addEventListener('message', handleParentMessage);

    function sendEventToServer(eventType, data) {
      sendToParent(eventType, data);
    }

    function packSliderEvent(position, timestamp) {
      if (position < 0 || position > 8191) return null;
      
      const packed = (BigInt(position) << 38n) | (BigInt(timestamp) & 0x3FFFFFFFFFn);
      
      const result = new Uint8Array(7);
      for (let i = 0; i < 7; i++) {
        result[6 - i] = Number((packed >> BigInt(i * 8)) & 0xFFn);
      }
      
      return result;
    }

    function packClickEvent(x, y, timestamp) {
      if (x < 0 || x > 8191 || y < 0 || y > 8191) return null;
      
      const packed = (BigInt(x) << 51n) | (BigInt(y) << 38n) | (BigInt(timestamp) & 0x3FFFFFFFFFn);
      
      const result = new Uint8Array(8);
      for (let i = 0; i < 8; i++) {
        result[7 - i] = Number((packed >> BigInt(i * 8)) & 0xFFn);
      }
      
      return result;
    }

    const challengeData = {
      challenge_id: "{{.ChallengeID}}",
      user_id: "{{.UserID}}",
      canvas_width: {{.CanvasWidth}},
      canvas_height: {{.CanvasHeight}},
      puzzle_width: {{.PuzzleWidth}},
      puzzle_height: {{.PuzzleHeight}},
      target_x: {{.TargetX}},
      tolerance: {{.Tolerance}},
      background_image: "{{.BackgroundImage}}",
      puzzle_shape: "{{.PuzzleShape}}"
    };

    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");
    const pieceEl = document.getElementById("piece");
    const slider = document.getElementById("slider");
    const msg = document.getElementById("msg");

    cv.width  = challengeData.canvas_width;
    cv.height = challengeData.canvas_height;
    pieceEl.style.width  = challengeData.puzzle_width + "px";
    pieceEl.style.height = challengeData.puzzle_height + "px";
    slider.max = String(challengeData.canvas_width - challengeData.puzzle_width);

    let bgImage = null;

    function loadImage() {
      console.log("loadImage() called");
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.referrerPolicy = "no-referrer";

      img.onload = () => {
        console.log("Фоновое изображение загружено успешно", img.width, "x", img.height);
        bgImage = img;
        drawAll(0);
      };
      img.onerror = (e) => {
        console.error("Ошибка загрузки фонового изображения:", e);
        bgImage = null;
        drawAll(0);
        setMsg("Изображение не загружено", "bad");
      };
      
      let imagePath = challengeData.background_image;
      if (imagePath && imagePath.startsWith('/')) {
        imagePath = window.location.origin + imagePath;
      }
      
      console.log("Загружаем фоновое изображение:", imagePath);
      img.src = imagePath;
    }

    function drawShape(ctx, x, y, w, h, shape, fill) {
      ctx.beginPath();
      
      switch(shape) {
        case 'circle':
          const radius = Math.min(w, h) / 2;
          const centerX = x + w / 2;
          const centerY = y + h / 2;
          ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
          break;
          
        case 'triangle':
          ctx.moveTo(x + w / 2, y);
          ctx.lineTo(x, y + h);
          ctx.lineTo(x + w, y + h);
          ctx.closePath();
          break;
          
        case 'diamond':
          ctx.moveTo(x + w / 2, y);
          ctx.lineTo(x + w, y + h / 2);
          ctx.lineTo(x + w / 2, y + h);
          ctx.lineTo(x, y + h / 2);
          ctx.closePath();
          break;
          
        case 'hexagon':
          const hexRadius = Math.min(w, h) / 2;
          const hexCenterX = x + w / 2;
          const hexCenterY = y + h / 2;
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const px = hexCenterX + hexRadius * Math.cos(angle);
            const py = hexCenterY + hexRadius * Math.sin(angle);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          break;
          
        case 'star':
          const starRadius = Math.min(w, h) / 2;
          const starCenterX = x + w / 2;
          const starCenterY = y + h / 2;
          const spikes = 5;
          const outerRadius = starRadius;
          const innerRadius = starRadius * 0.4;
          
          for (let i = 0; i < spikes * 2; i++) {
            const angle = (i * Math.PI) / spikes;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const px = starCenterX + radius * Math.cos(angle - Math.PI / 2);
            const py = starCenterY + radius * Math.sin(angle - Math.PI / 2);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          break;
          
        case 'square':
        default:
          ctx.rect(x, y, w, h);
          break;
      }
      
      if (fill) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }

    function drawBackground() {
      console.log("drawBackground called, bgImage:", bgImage);
      ctx.clearRect(0, 0, cv.width, cv.height);
      if (bgImage) {
        console.log("Drawing background image:", bgImage.width, "x", bgImage.height);
        ctx.drawImage(bgImage, 0, 0, bgImage.width, bgImage.height, 0, 0, cv.width, cv.height);
      } else {
        console.log("No background image, drawing white background");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, cv.width, cv.height);
      }
    }

    function drawTargetHole() {
      const y = 50;
      const { puzzle_width: w, puzzle_height: h, target_x: x, puzzle_shape: shape } = challengeData;
      
      ctx.fillStyle = "rgba(0,0,0,.28)";
      drawShape(ctx, x, y, w, h, shape, true);
      
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#1976d2";
      drawShape(ctx, x + 1, y + 1, w - 2, h - 2, shape, false);
    }

    function drawPieceAt(x) {
      pieceEl.style.left = x + "px";
      pieceEl.style.top  = "50px";

      pieceEl.replaceChildren();
      const pz = document.createElement("canvas");
      pz.width = challengeData.puzzle_width;
      pz.height = challengeData.puzzle_height;
      const pctx = pz.getContext("2d");

      if (bgImage && bgImage.naturalWidth > 0) {
        const scaleX = bgImage.width / cv.width;
        const scaleY = bgImage.height / cv.height;
        const srcX = challengeData.target_x * scaleX;
        const srcY = 50 * scaleY;
        const srcW = challengeData.puzzle_width * scaleX;
        const srcH = challengeData.puzzle_height * scaleY;

        pctx.drawImage(bgImage, srcX, srcY, srcW, srcH, 0, 0, pz.width, pz.height);
      } else {
        pctx.fillStyle = "#ffffff";
        pctx.fillRect(0, 0, pz.width, pz.height);
      }

      pctx.globalCompositeOperation = 'destination-in';
      drawShape(pctx, 0, 0, pz.width, pz.height, challengeData.puzzle_shape, true);
      pctx.globalCompositeOperation = 'source-over';

      pctx.lineWidth = 2;
      pctx.strokeStyle = "#1976d2";
      drawShape(pctx, 0, 0, pz.width, pz.height, challengeData.puzzle_shape, false);

      pieceEl.appendChild(pz);
    }

    function drawAll(x) {
      console.log("drawAll called with x:", x, "bgImage:", bgImage);
      drawBackground();
      drawTargetHole();
      drawPieceAt(x);
    }

    function setMsg(text, kind) {
      msg.textContent = text || "";
      msg.className = "msg" + (kind ? " " + kind : "");
    }

    function check() {
      const x = parseInt(slider.value);
      const dist = Math.abs(x - challengeData.target_x);
      const isCorrect = dist <= challengeData.tolerance;
      
      if (isCorrect) {
        setMsg("Успешно! Капча пройдена.", "ok");
        sendToParent('captchaSolved', {
          position: x,
          distance: dist,
          timestamp: Date.now()
        });
      } else {
        setMsg("Неверно. Попробуйте ещё раз.", "bad");
        sendToParent('captchaFailed', {
          position: x,
          distance: dist,
          target: challengeData.target_x,
          timestamp: Date.now()
        });
      }
    }

    slider.addEventListener("input", () => {
      const x = parseInt(slider.value) || 0;
      drawAll(x);
      setMsg(""); 
      
      const binaryData = packSliderEvent(x, Date.now());
      if (binaryData) {
        sendEventToServer('slider_moved', binaryData);
      }
    });

    slider.addEventListener("change", () => {
      check();
      
      const x = parseInt(slider.value) || 0;
      const dist = Math.abs(x - challengeData.target_x);
      const isCorrect = dist <= challengeData.tolerance;
      
      sendEventToServer('challenge_completed', {
        position: x,
        targetPosition: challengeData.target_x,
        distance: dist,
        isCorrect: isCorrect,
        timestamp: Date.now()
      });
    });

    function sendEventToServer(eventType, data) {
      try {
        window.top.postMessage({
          type: 'captcha:sendData',
          challengeId: challengeData.challenge_id || 'unknown',
          userId: challengeData.user_id || 'anonymous',
          eventType: eventType,
          data: data
        }, '*');
      } catch (error) {
        console.error('Failed to send event to server:', error);
      }
    }

    function handleServerMessage(event) {
      if (event.data?.type === "captcha:serverData") {
        console.log('Received server data:', event.data.data);
      }
    }

    window.addEventListener("message", handleServerMessage);

    sendEventToServer('interaction_started', {
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    });

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadImage);
    } else {
      loadImage();
    }

    sendToParent('captchaLoaded', {
      challengeId: challengeData.challenge_id,
      timestamp: Date.now()
    });
  </script>
</body>
</html>